<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Population Projection Calculator - Dark Mode</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* Modern Dark Mode Color Variables */
      :root {
        --color-background-body: #121212;
        --color-background-card: #1e1e1e;
        --color-text-primary: #e0e0e0;
        --color-text-secondary: #b3b3b3;
        --color-accent: #00bcd4; /* Cyan/Teal for modern look */
        --color-accent-hover: #00a4b8;
        --color-border: #333333;
        --color-input-bg: #2d2d2d;
        --color-result-item-bg: #282828;
        --color-shadow: rgba(0, 0, 0, 0.5);
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 30px 20px;
        background-color: var(--color-background-body);
        color: var(--color-text-primary);
        line-height: 1.6;
      }

      .calculator,
      .results,
      .chart-container {
        background: var(--color-background-card);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 4px 15px var(--color-shadow);
        margin-bottom: 25px;
        transition: box-shadow 0.3s ease;
      }

      h1,
      h2 {
        color: var(--color-accent);
        border-bottom: 2px solid var(--color-border);
        padding-bottom: 10px;
        margin-top: 0;
      }

      p {
        color: var(--color-text-secondary);
      }

      .input-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        font-size: 1rem;
      }

      input {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--color-border);
        border-radius: 6px;
        box-sizing: border-box;
        background-color: var(--color-input-bg);
        color: var(--color-text-primary);
        font-size: 1rem;
        transition: border-color 0.3s;
      }

      input:focus {
        border-color: var(--color-accent);
        outline: none;
      }

      button {
        width: 100%;
        background-color: var(--color-accent);
        color: var(--color-background-card);
        padding: 12px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: bold;
        transition: background-color 0.3s, transform 0.1s;
      }

      button:hover {
        background-color: var(--color-accent-hover);
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0);
      }

      .result-item {
        margin: 12px 0;
        padding: 15px;
        background: var(--color-result-item-bg);
        border-left: 5px solid var(--color-accent);
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .result-item strong {
        font-weight: 600;
      }

      .result-item span {
        font-weight: bold;
        color: var(--color-accent);
        font-size: 1.1rem;
      }
    </style>
  </head>
  <body>
    <div class="calculator">
      <h1>Population Projection Calculator</h1>
      <p>
        This tool projects population change using Total Fertility Rate (TFR),
        Life Expectancy, and Median Age. It models population aging and births
        directly â€” no crude birth/death rates are used.
      </p>

      <div class="input-group">
        <label for="initialPopulation">Initial Population ($P_i$):</label>
        <input
          type="text"
          id="initialPopulation"
          value="1,000,000"
          data-number-value="1000000"
        />
      </div>

      <div class="input-group">
        <label for="tfr">Total Fertility Rate (children per woman):</label>
        <input type="number" id="tfr" value="2.1" step="0.1" min="0" max="10" />
      </div>

      <div class="input-group">
        <label for="lifeExpectancy">Life Expectancy (years):</label>
        <input
          type="number"
          id="lifeExpectancy"
          value="80"
          step="1"
          min="1"
          max="120"
        />
      </div>

      <div class="input-group">
        <label for="medianAge">Median Age (years):</label>
        <input
          type="number"
          id="medianAge"
          value="35"
          step="1"
          min="0"
          max="120"
        />
      </div>

      <div class="input-group">
        <label for="years">Years to Project:</label>
        <input type="number" id="years" value="100" min="1" max="300" />
      </div>

      <button onclick="simulatePopulation()">Simulate Population</button>
    </div>

    <div class="results" id="results" style="display: none">
      <h2>Projection Summary</h2>
      <div class="result-item">
        <strong>Final Population:</strong> <span id="finalPop"></span>
      </div>
      <div class="result-item">
        <strong>Total Change:</strong> <span id="change"></span>
      </div>
      <div class="result-item">
        <strong>Percentage Change:</strong> <span id="pctChange"></span>
      </div>
    </div>

    <div class="chart-container">
      <h2>Population Trend</h2>
      <canvas id="populationChart"></canvas>
    </div>

    <script>
      let populationChart = null;
      // Define dark mode colors for Chart.js
      const chartAccentColor = getComputedStyle(document.documentElement)
        .getPropertyValue("--color-accent")
        .trim();
      const chartTextColor = getComputedStyle(document.documentElement)
        .getPropertyValue("--color-text-primary")
        .trim();
      const chartGridColor =
        getComputedStyle(document.documentElement)
          .getPropertyValue("--color-border")
          .trim() + "80"; // Add transparency

      // --- New Formatting Functions ---

      // Formats a number with locale-specific thousands separators (commas in en-US)
      function formatNumberWithCommas(n) {
        // Use the built-in Number.prototype.toLocaleString for robust, locale-aware formatting
        return Number(n).toLocaleString(undefined, {
          maximumFractionDigits: 0,
        });
      }

      // Cleans an input string, removing all non-digit characters except an optional leading sign
      function cleanNumberString(s) {
        return s.replace(/[^\d]/g, ""); // Remove all non-digits
      }

      // Handler for the Initial Population input field
      function handleInitialPopulationInput(event) {
        const inputElement = event.target;
        const rawValue = cleanNumberString(inputElement.value);

        // Store the raw, clean numeric value in the data attribute for calculations
        inputElement.setAttribute("data-number-value", rawValue);

        if (rawValue) {
          // Format the display value with commas
          inputElement.value = formatNumberWithCommas(rawValue);
        } else {
          // Keep the field clear if the user deletes all content
          inputElement.value = "";
        }
      }

      // --- End New Formatting Functions ---

      function simulatePopulation() {
        const initialPopElement = document.getElementById("initialPopulation");

        // *** CRITICAL CHANGE ***: Read the raw value from the data attribute
        const initialPop = parseFloat(
          initialPopElement.getAttribute("data-number-value")
        );
        const tfr = parseFloat(document.getElementById("tfr").value);
        const lifeExp = parseFloat(
          document.getElementById("lifeExpectancy").value
        );
        const medianAge = parseFloat(
          document.getElementById("medianAge").value
        );
        const years = parseInt(document.getElementById("years").value);

        if (
          [initialPop, tfr, lifeExp, medianAge, years].some(isNaN) ||
          initialPop <= 0
        ) {
          alert(
            "Please ensure Initial Population is a valid number greater than 0, and all other fields are filled correctly."
          );
          return;
        }

        const maxAge = Math.max(Math.ceil(lifeExp * 1.5), 3);
        const burnYears = Math.max(5 * maxAge, 200); // enough to converge

        // Build a stable age structure via burn-in from a 1-person seed
        let populationByAge = buildStablePopulation(
          tfr,
          lifeExp,
          maxAge,
          burnYears
        );

        // Nudge median age smoothly if requested
        const currentMedian = computeMedianAge(populationByAge);
        const shift = medianAge - currentMedian;
        if (Math.abs(shift) > 0.05)
          populationByAge = fractionalShift(populationByAge, shift);

        // Scale to the requested initial population total
        const sum = populationByAge.reduce((a, b) => a + b, 0);
        populationByAge = populationByAge.map((v) => v * (initialPop / sum));

        // Run the main projection
        const results = [];
        for (let year = 0; year <= years; year++) {
          const totalPop = populationByAge.reduce((a, b) => a + b, 0);
          results.push(totalPop);

          // Births: The population aged 15..49 (inclusive of 15, exclusive of 50).
          const startF = Math.max(0, 15);
          const endF = Math.min(maxAge, 50);
          const fertilePopulation = populationByAge
            .slice(startF, endF)
            .reduce((a, b) => a + b, 0);

          // 1. Assume 50% of the fertile population are women.
          const women = fertilePopulation / 2;
          // 2. Divide TFR by 2 (approx GRR) and by 35 (fertility years) for annual female births per woman.
          const femaleBirthsPerWomanPerYear = tfr / 2 / 35;
          // 3. Total new newborns (age 0) are total births (M+F).
          const totalBirths = women * femaleBirthsPerWomanPerYear * 2;

          // Age population: apply survival of age a to those at age a (moving them into a+1)
          const newAges = new Array(maxAge).fill(0);
          for (let a = 0; a < maxAge - 1; a++) {
            const surv = annualSurvival(a, lifeExp); // survival for age a -> a+1
            newAges[a + 1] = populationByAge[a] * surv;
          }
          newAges[0] = totalBirths; // Use the corrected total births
          populationByAge = newAges;
        }

        const finalPop = results[results.length - 1];
        const change = finalPop - initialPop;
        const pctChange = ((change / initialPop) * 100).toFixed(2);

        document.getElementById("results").style.display = "block";
        document.getElementById("finalPop").textContent =
          finalPop.toLocaleString(undefined, { maximumFractionDigits: 0 });
        document.getElementById("change").textContent =
          (change >= 0 ? "+" : "") +
          change.toLocaleString(undefined, { maximumFractionDigits: 0 });
        document.getElementById("pctChange").textContent =
          (pctChange >= 0 ? "+" : "") + pctChange + "%";

        drawChart(results);
      }

      // Build stable population via burn-in
      function buildStablePopulation(tfr, lifeExp, maxAge, burnYears) {
        let pop = new Array(maxAge).fill(0);
        pop[0] = 1.0; // single newborn seed

        for (let y = 0; y < burnYears; y++) {
          const fertilePopulation = pop
            .slice(15, 50)
            .reduce((a, b) => a + b, 0);
          const women = fertilePopulation / 2;
          const femaleBirthsPerWomanPerYear = tfr / 2 / 35;
          const totalBirths = women * femaleBirthsPerWomanPerYear * 2;

          const next = new Array(maxAge).fill(0);
          for (let a = 0; a < maxAge - 1; a++) {
            next[a + 1] = pop[a] * annualSurvival(a, lifeExp);
          }
          next[0] = totalBirths;
          pop = next;
        }

        const total = pop.reduce((a, b) => a + b, 0);
        return pop.map((v) => v / total);
      }

      // Simple, stable annual survival
      function annualSurvival(age, lifeExp) {
        // This is a simple, uniform survival model for stability, not a true life table.
        const annualSurvivalRate = Math.exp(-1.0 / Math.max(lifeExp, 1));
        return annualSurvivalRate;
      }

      // Compute median age (fractional inside bin)
      function computeMedianAge(arr) {
        const total = arr.reduce((a, b) => a + b, 0);
        let cum = 0;
        for (let i = 0; i < arr.length; i++) {
          const prev = cum;
          cum += arr[i];
          if (cum >= total / 2) {
            const within = (total / 2 - prev) / (arr[i] || 1);
            return i + within;
          }
        }
        return arr.length - 1;
      }

      // Fractional shift of distribution (positive => older)
      function fractionalShift(arr, shift) {
        const n = arr.length;
        const out = new Array(n).fill(0);
        for (let i = 0; i < n; i++) {
          const src = i - shift;
          const lo = Math.floor(src);
          const hi = lo + 1;
          const frac = src - lo;
          if (lo >= 0 && lo < n) out[i] += arr[lo] * (1 - frac);
          if (hi >= 0 && hi < n) out[i] += arr[hi] * frac;
        }
        const s = out.reduce((a, b) => a + b, 0);
        const orig = arr.reduce((a, b) => a + b, 0);
        if (s > 0) return out.map((v) => v * (orig / s));
        return arr.slice();
      }

      // Charting
      function drawChart(populationArray) {
        const ctx = document.getElementById("populationChart").getContext("2d");
        if (populationChart) populationChart.destroy();

        populationChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: populationArray.map((_, i) => i),
            datasets: [
              {
                label: "Population",
                data: populationArray,
                borderColor: chartAccentColor,
                backgroundColor: chartAccentColor + "40", // Semi-transparent fill
                borderWidth: 3,
                fill: true,
                tension: 0.4, // Smoother lines
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: false }, // Title is in the h2
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) =>
                    `Year ${ctx.label}: ${ctx.parsed.y.toLocaleString(
                      undefined,
                      { maximumFractionDigits: 0 }
                    )}`,
                },
                backgroundColor: "rgba(30, 30, 30, 0.9)",
                titleColor: chartAccentColor,
                bodyColor: chartTextColor,
              },
            },
            scales: {
              x: {
                title: { display: true, text: "Years", color: chartTextColor },
                ticks: { color: chartTextColor },
                grid: { color: chartGridColor },
              },
              y: {
                title: {
                  display: true,
                  text: "Population",
                  color: chartTextColor,
                },
                ticks: {
                  callback: (v) =>
                    v.toLocaleString(undefined, { maximumFractionDigits: 0 }),
                  color: chartTextColor,
                },
                grid: { color: chartGridColor },
              },
            },
          },
        });
      }

      // --- Initialization Logic ---
      window.onload = () => {
        const initialPopInput = document.getElementById("initialPopulation");

        // 1. Initial format of the default value
        initialPopInput.value = formatNumberWithCommas(
          initialPopInput.getAttribute("data-number-value")
        );

        // 2. Add event listeners for dynamic formatting
        initialPopInput.addEventListener("input", handleInitialPopulationInput);
        initialPopInput.addEventListener("blur", handleInitialPopulationInput); // Ensures it's formatted when focus is lost

        // 3. Run the initial simulation with the newly formatted value
        simulatePopulation();
      };
    </script>
  </body>
</html>
